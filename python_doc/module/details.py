# 模块包含可执行语句及函数定义。这些语句用于初始化模块，且仅在 import 语句 第一次 遇到模块名时执行。[1] (文件作为脚本运行时，也会执行这些语句。)
# 每个模块都有自己的私有命名空间，它会被用作模块中定义的所有函数的全局命名空间。 
# 因此，模块作者可以在模块内使用全局变量而不必担心与用户的全局变量发生意外冲突。 
# 另一方面，如果你知道要怎么做就可以通过与引用模块函数一样的标记法 modname.itemname 来访问一个模块的全局变量。

# 模块可以导入其他模块。 
# 根据惯例可以将所有 import 语句都放在模块（或者也可以说是脚本）的开头但这并非强制要求。
# 如果被放置于一个模块的最高层级，则被导入的模块名称会被添加到该模块的全局命名空间。

# 还有一种 import 语句的变化形式可以将来自某个模块的名称直接导入到导入方模块的命名空间中。 例如:
from fibo import fib, fib2
fib(500)
# 这条语句不会将所导入的模块的名称引入到局部命名空间中（因此在本示例中，fibo 将是未定义的名称）

# 还有一种变体可以导入模块内定义的所有名称：
# from fibo import *
# fib(500)
# 这种方式会导入所有不以下划线（_）开头的名称。大多数情况下，不要用这个功能，这种方式向解释器导入了一批未知的名称，可能会覆盖已经定义的名称

# 模块名后使用 as 时，直接把 as 后的名称与导入模块绑定
import fibo as fib
fib.fib(500)
# 与 import fibo 一样，这种方式也可以有效地导入模块，唯一的区别是，导入的名称是 fib
# from 中的 as 也可以使用，效果类似

#  为了保证运行效率，每次解释器会话只导入一次模块
#  如果更改了模块内容，必须重启解释器；仅交互测试一个模块时，也可以使用 importlib.reload()，例如 import importlib; importlib.reload(modulename)



# 当导入一个名为 spam 的模块时，解释器首先会搜索具有该名称的内置模块。 这些模块的名称在 sys.builtin_module_names 中列出
# 如果未找到，它将在变量 sys.path 所给出的目录列表中搜索名为 spam.py 的文件
# sys.path 是从这些位置初始化的: 被命令行直接运行的脚本所在的目录（或未指定文件时的当前目录）
# PYTHONPATH （目录列表，与 shell 变量 PATH 的语法一样）
# 依赖于安装的默认值（按照惯例包括一个 site-packages 目录，由 site 模块处理）

# 初始化后，Python 程序可以更改 sys.path。脚本所在的目录先于标准库所在的路径被搜索。
# 这意味着，脚本所在的目录如果有和标准库同名的文件，那么加载的是该目录里的，而不是标准库的。这一般是一个错误，除非这样的替换是你有意为之。


# 为了快速加载模块，Python 把模块的编译版本缓存在 __pycache__ 目录中，文件名为 module.version.pyc，version 对编译文件格式进行编码，一般是 Python 的版本号。
# 例如，CPython 的 3.3 发行版中，spam.py 的编译版本缓存为 __pycache__/spam.cpython-33.pyc。这种命名惯例让不同 Python 版本编译的模块可以共存