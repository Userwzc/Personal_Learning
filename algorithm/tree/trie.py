# Trie树也叫字典树/前缀树
# 是多叉树结构的延伸，是一种针对字符串进行特殊优化的数据结构
# Trie树在处理字符串相关操作时有诸多优势，比如节省公共字符串前缀的内存空间、方便处理前缀操作、支持通配符等


# 先来梳理一下我们已经实现过的Map/Set结构
# 标准的哈希表HashMap,底层借助一个哈希函数把键值对存在table数组中，有两种解决哈希冲突的方法。它的特点是快，即基本的增删查改操作时间复杂度都是O(1)。哈希结合HashSet是HashMap的简单封装
# 哈希链表LinkedHashMap,是双链表结构对哈希表的加强，它继承了哈希表的操作复杂度，并且可以让哈希表中的所有键保持[插入顺序].LinkedHashSet是LinkedHashMap的简单封装
# 哈希数组ArrayHashMap,是数组结构对标准哈希表的加强，它继承了哈希表的操作复杂度，并且提供了一个额外的randomKey函数,可以在O(1)的时间返回一个随机键.ArrayHashSet是ArrayHashMap的简单封装
# TreeMap，底层是一颗二叉搜索树（一般使用经过改良的自平衡红黑树),基本增删查改操作复杂度是O(logN),它的特点是可以动态维护键值对的大小关系，有很多额外的API操作键值对。TreeSet集合是TreeMap映射的简单封装

class TrieNode():
    def __init__(self):
        self.val = None       # 存储对应的值
        self.children = [None] * 256  # 存储指向子节点的指针
        # 但是和之前的普通多叉树节点不同,TrieNode中children数组的索引是有意义的，代表键中的一个字符
        # 比如说children[97]如果非空,说明这里存储了一个字符'a',因为'a'的ASCII码是97
        # 模板只考虑处理ASCII字符，所以children数组的大小设置为256,这个可以根据具体问题修改
        # 在实际做题时，题目说了只包含字符a-z，那么可以把大小改为26;
        # 或者不想用字符索引来映射，直接用哈希表来存储children也是可以的

        # 特别注意，TrieNode节点本身只存储val字段，不存储字符信息，字符信息是隐含在父节点的children数组的索引中的
        # 形象理解就是,Trie树用[树枝]存储字符串（键），用[节点]存储对应的值

