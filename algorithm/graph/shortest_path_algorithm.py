# 图结构最短路径算法概览

# Dijkstra算法和A*算法是图结构BFS的拓展，可以处理不包含负权重的单源最短路径问题。
# SPFA算法(基于队列的Bellman-Ford算法)是图的BFS拓展，可以处理包含负权重的单源最短路径问题。
# Floyd算法是动态规划的应用，可以处理多源最短路径问题.

# 单源最短路径问题
# Dijkstra算法，其本质是BFS算法 + 贪心思想，效率较高，但是不能处理带有负权重的图。
# 基于队列的Bellman-Ford算法,其本质也是BFS算法，可以处理带有负权重的图，但是效率比Dijkstra算法低。

# 点对点最短路径问题
# 一般来说，点对点最短路径问题可以视为单源最短路径问题的特例，你可以从src开始执行单源最短路径算法，当算出到达dst的最短路径时提前结束算法。
# A*算法是专门处理点对点问题的算法
# 算法的本质是穷举，你要提高穷举的效率，就得尽可能充分地利用信息。
# 点对点最短路径问题(已知起点和终点)比单源最短路径问题(只知道起点)多了终点信息，所以完全有可能利用这个信息来提高算法效率。
# A*算法的关键在于：它能够充分利用已知信息，有方向性的搜索，更快的找到终点，我们称这类算法为启发式搜索算法。
# 启发式算法需要合理设置启发函数，在经验法则和实际情况中找到平衡，确保在经验法则失效时，算法的效率也不会太差。

# 多源最短路径问题

# 负权重边的影响：想让Dijkstra算法这类包含贪心思想的算法成立，需要一个前提：它假设随着经过的边的数量增加，路径权重和一定也会增加。但负权重边的出现打破了这一假设，导致算法失效。
# 如果图中存在负权重环，则不存在最短路径，因为可以通过不断经过负权重环来使路径权重和无限减小。

# 常见的最短路径算法中，Dijkstra算法和A*算法不能处理含有负权重边的图，Floyd算法和Bellman-Ford算法可以处理负权重边，Bellman-Ford算法常用来检测负权重环。


# Dijkstra算法简介
# 优先扩散权重和最小的路径，最先到达终点的路径就是权重和最小的路径。这就是贪心思想的体现
# 对比标准BFS算法，只需要修改两个地方即可得到Dijkstra算法:
# 1.标准BFS算法使用普通队列，Dijkstra算法使用优先队列。
# 2.标准BFS算法使用一个`visited`数组来记录访问过的节点，确保算法不会陷入死循环；Dijkstra算法使用一个`distTo`数组，确保算法不会陷入死循环，同时记录起点到其他节点的最短路径。

# A*算法简介
# 对于任意节点x，我们用g(x)表示从起点src到节点x的距离，用h(x)表示启发函数，用于估计从节点x到终点dst的距离。
# 那么Dijkstra算法就是借助优先队列，让g(x)最小的节点先出队，从而保证终点第一次出队时，就找到了最短路径。
# 而A*算法中稍作一点改动：让f(x) = g(x) + h(x) 最小的节点优先出队，终点第一次出队时，就找到了最短路径。
# f(x)函数虽然简单，却非常精妙：
# 无论是接近终点还是远离终点，g(x)肯定是不断增大的。
# 但是接近终点时，h(x)会逐渐减小，远离终点时，h(x)会逐渐增大。


# Bellman-Ford/SPFA算法简介
# 当说到包含负权重边的最短路径问题时，经常提到Bellman-Ford算法和SPFA算法.
# 当我们说Bellman-Ford算法时，一般是指朴素Bellman-Ford算法，当我们说SPFA算法时，是指对朴素Bellman-Ford算法的一种优化，即基于队列的Bellman-Ford算法。
# 对比标准的BFS算法，SPFA算法只有一个地方不一样：
# 标准BFS算法使用一个布尔数组`visited`确保每个节点只会遍历一次，避免算法陷入死循环；SPFA算法中，需要使用`inQueue`,`count`数组配合，确保算法不会陷入死循环，同时用一个`distTo`数组来记录起点到其他节点的最短路径。


# Floyd算法简介
# 核心思想是动态规划，和前面讲的基于BFS的最短路径算法完全不同
# 思想：如果节点i和节点j之间存在最短路径：
# 如果节点i和节点j之间有直接相连的边，那么节点i到节点j的最短路径就是这条边的权重。
# 如果节点i和节点j之间没有直接相连的边，那么肯定要经过至少1个其他节点。
# 对于任意一个其他节点k，如果最短路径经过k，那么节点i到节点j的最短路径就是节点i到节点k的最短路径加上节点k到节点j的最短路径。
# 这样一来，原问题[i到j的最短路径]就变成了两个结构相同，规模更小的子问题[i到k的最短路径]和[k到j的最短路径],这就是动态规划的特征，根据这个思路来推导转移方程。