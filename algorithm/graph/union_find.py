# Union Find 并查集原理

# 并查集(Union Find)结构是二叉树结构的衍生，用于高效解决无向图的连通性问题，可以在O(1)时间内合并两个连通分量，在O(1)时间内查询两个节点是否连通，在O(1)时间内查询连通分量的数量。
# 连通关系的性质：
# 1.自反性：任意节点与其自身连通。
# 2.对称性：如果节点A与节点B连通，那么节点B与节点A也连通。
# 3.传递性：如果节点A与节点B连通，节点B与节点C连通，那么节点A与节点C也连通。
# 判断这种[等价关系]非常实用，比如说编译器判断同一个内存对象的不同变量引用，比如社交网络中的朋友圈计算等等。
# 动态连通性问题就是说，给你输入一个图结构，然后进行若干次[连接操作]，同时可能会查询任意两个节点是否[连通],或者查询当前图中有多少个[连通分量].

# 并查集算法非常巧妙，它不仅可以在O(1)时间内完成上述操作，而且它根本不需要真的用邻接表/邻接矩阵构造图结构，只需要一个数组就可以了。

# 并查集的核心原理
# 对于一颗树，其中的所有节点，是不是都只有同一个根节点？
# 如果我们想办法把同一个连通分量的节点都放到同一颗树中，把这棵树的根节点作为这个连通分量的代表，那么我们就可以高效实现上面的操作了。
# 并查集底层其实是一片森林(若干颗多叉树),每棵树代表一个连通分量：
# connected(p,q)操作：只需要判断p和q所在多叉树的根节点，若相同，则p和q在同一颗树中，即连通，否则不连通。
# count()操作: 只需要统计一下总共有多少颗树，即可得到连通分量的数量。
# union(p,q)：只需要将p节点所在的这棵树的根节点，接入到q节点所在的这颗树的根节点下面，即可完成连接操作。注意这里并不是p,q两个节点的合并，而是两颗树根节点的合并。因为p,q一旦连通，那么他们所属的连通分量就合并成了同一个更大的连通分量。
# 并查集的最终目标，就是要尽可能降低树的高度，如果能保持树高为常数，那么上述方法的复杂度就都是O(1)了。
# 仔细思考可以发现，使得树高线性增长的原因是，每次union操作都是将节点个数较多的树接到了节点个数较少的树下面，这就很容易让树高增加，很不明智。
# 一个优化思路是引入一个权重数组，记录以每个节点为根节点的树的节点个数，然后在union操作中，总是将节点个数较少的树接到节点个数较多的树下面，这样可以保证树尽可能平衡，树高也就不会线性增长。
# 这样可以保证最终树高在O(logN)级别，所以union,connected,find方法的时间复杂度都是O(logN)

# 路径压缩(Path Compression)优化，均摊复杂度为O(1),这样就可以保证union,connected,find方法的时间复杂度都是常数级别O(1).